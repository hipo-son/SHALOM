import os
import signal
import concurrent.futures
from typing import Dict, Any, Optional


class TimeoutException(Exception):
    """Raised when code execution exceeds the allowed time limit."""

    pass


class SafeExecutor:
    """Sandbox environment to securely execute Python scripts generated by LLMs.

    Provides execution timeouts (cross-platform) and restricts imported
    modules to a whitelist. On POSIX systems, ``signal.SIGALRM`` is used
    for precise timeout enforcement. On Windows and other platforms,
    ``concurrent.futures.ThreadPoolExecutor`` serves as the fallback.

    Warning:
        This sandbox is NOT a production-grade security boundary.
        For untrusted environments, use Docker/WASM-based isolation.
    """

    # Whitelisted built-in functions for the secure execution environment.
    # ``__import__`` is explicitly set to None to block dynamic imports.
    WHITELISTED_LOCALS: Dict[str, Any] = {
        "__builtins__": {
            "__import__": None,
            "abs": abs,
            "all": all,
            "any": any,
            "bool": bool,
            "dict": dict,
            "enumerate": enumerate,
            "float": float,
            "int": int,
            "len": len,
            "list": list,
            "max": max,
            "min": min,
            "range": range,
            "round": round,
            "set": set,
            "str": str,
            "sum": sum,
            "tuple": tuple,
            "zip": zip,
            "True": True,
            "False": False,
            "None": None,
            "print": print,
        }
    }

    @staticmethod
    def _timeout_handler(signum: int, frame: Any) -> None:
        raise TimeoutException("Execution timed out.")

    @classmethod
    def execute(
        cls,
        code_string: str,
        local_vars: Optional[Dict[str, Any]] = None,
        timeout_seconds: int = 10,
    ) -> Dict[str, Any]:
        """Execute a Python script safely with a timeout and whitelisted scope.

        Args:
            code_string: Python script to execute.
            local_vars: Dictionary to serve as the local execution scope.
                Trusted libraries (e.g. ASE, NumPy) should be passed here.
            timeout_seconds: Maximum execution time in seconds. Defaults to 10.

        Returns:
            A dictionary containing the local state after execution.

        Raises:
            TimeoutException: If execution exceeds ``timeout_seconds``.
        """
        allow_unsafe = os.environ.get("SHALOM_ALLOW_UNSAFE_EXEC", "0") == "1"

        if local_vars is None:
            local_vars = {}

        if not allow_unsafe:
            global_scope = cls.WHITELISTED_LOCALS.copy()
        else:
            global_scope = globals()

        has_signals = hasattr(signal, "SIGALRM")

        if has_signals and not allow_unsafe:
            # POSIX: use signal-based timeout (precise, single-threaded)
            old_handler = signal.signal(signal.SIGALRM, cls._timeout_handler)  # type: ignore[attr-defined, arg-type]
            signal.alarm(timeout_seconds)  # type: ignore[attr-defined]
            try:
                exec(code_string, global_scope, local_vars)  # noqa: S102
            finally:
                signal.alarm(0)  # type: ignore[attr-defined]
                signal.signal(signal.SIGALRM, old_handler)  # type: ignore[attr-defined, arg-type]
        else:
            # Windows / fallback: use ThreadPoolExecutor for cross-platform timeout
            def _run() -> None:
                exec(code_string, global_scope, local_vars)  # noqa: S102

            with concurrent.futures.ThreadPoolExecutor(max_workers=1) as executor:
                future = executor.submit(_run)
                try:
                    future.result(timeout=timeout_seconds)
                except concurrent.futures.TimeoutError:
                    raise TimeoutException("Execution timed out.")

        return local_vars
